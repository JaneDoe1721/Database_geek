
# «Операторы, фильтрация, сортировка и ограничение»


# № 1 Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
# заполняю столбцы created_at и update_at
mysql> UPDATE users SET created_at = NOW(), update_at = NOW();
Query OK, 10 rows affected (0,08 sec)
Rows matched: 10  Changed: 10  Warnings: 0

# проверка записи
mysql> SELECT * FROM users;
+----+--------------------+-------------+---------------------+---------------------+
| id | name               | birthday_at | created_at          | update_at           |
+----+--------------------+-------------+---------------------+---------------------+
|  2 | Геннадий           | 1990-10-05  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  3 | Наталья            | 1984-11-12  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  4 | Александр          | 1985-05-20  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  5 | Сергей             | 1988-02-14  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  6 | Иван               | 1998-01-12  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  7 | Мария              | 1992-08-29  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  8 | АЛександа          | 1980-01-20  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
|  9 | Светлана           | 1988-02-04  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
| 10 | Олег               | 1998-03-20  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
| 11 | Юлия               | 2006-07-12  | 2020-06-29 18:14:16 | 2020-06-29 18:14:16 |
+----+--------------------+-------------+---------------------+---------------------+
10 rows in set (0,00 sec)

# № 2 Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10. Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
# изменение типа данных двух столбцов
mysql> ALTER TABLE users MODIFY update_at DATETIME;
Query OK, 10 rows affected (0,11 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE users MODIFY created_at DATETIME;
Query OK, 10 rows affected (0,03 sec)
Records: 10  Duplicates: 0  Warnings: 0


# № 3 Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения значения value. Однако нулевые запасы должны выводиться в конце, после всех 
# заполнение таблицы storehouses_products
mysql> INSERT INTO storehouses_products (value, product_id, storehouse_id) VALUES
    ->  (1000, 1, 1),
    ->  (500, 1, 1),
    ->  (10, 2, 2),
    ->  (10, 2, 2),
    ->  (5, 1, 2),
    ->  (0, 1, 1),
    ->  (7, 2, 1),
    ->  (700, 1, 3),
    ->  (1, 3, 3),
    ->  (0, 1, 3);
Query OK, 10 rows affected (0,39 sec)
Records: 10  Duplicates: 0  Warnings: 0


# вывод отсортированных значений таблицы 
# CASE проверяет истинность набора условий
# WHEN - когда value равно 0
# THEN 1000 -  после занчения 1000 
mysql> SELECT * FROM storehouses_products
    ->  ORDER BY CASE WHEN value = 0 THEN 1000 ELSE value END
    -> ;
+----+---------------+------------+-------+---------------------+---------------------+
| id | storehouse_id | product_id | value | created_at          | updated_at          |
+----+---------------+------------+-------+---------------------+---------------------+
|  9 |             3 |          3 |     1 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  5 |             2 |          1 |     5 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  7 |             1 |          2 |     7 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  3 |             2 |          2 |    10 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  4 |             2 |          2 |    10 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  2 |             1 |          1 |   500 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  8 |             3 |          1 |   700 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  1 |             1 |          1 |  1000 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
|  6 |             1 |          1 |     0 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
| 10 |             3 |          1 |     0 | 2020-06-29 18:34:32 | 2020-06-29 18:34:32 |
+----+---------------+------------+-------+---------------------+---------------------+
10 rows in set (0,00 sec)

# №4(по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. Месяцы заданы в виде списка английских названий (may, august)

# вывод пользователей у которых день рождения в мае и августе
mysql> SELECT
    ->     name, birthday_at, 
    ->     CASE 
    ->         WHEN DATE_FORMAT(birthday_at, '%m') = 05 THEN 'may'
    ->         WHEN DATE_FORMAT(birthday_at, '%m') = 08 THEN 'august'
    ->     END AS mounth
    -> FROM
    ->     users WHERE DATE_FORMAT(birthday_at, '%m') = 05 OR DATE_FORMAT(birthday_at, '%m') = 08;
+--------------------+-------------+--------+
| name               | birthday_at | mounth |
+--------------------+-------------+--------+
| Александр          | 1985-05-20  | may    |
| Мария              | 1992-08-29  | august |
+--------------------+-------------+--------+
2 rows in set (0,00 sec)

# №5 (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.
# отсортированны записи в порядке заданном в списке
mysql> SELECT * FROM catalogs
    ->  WHERE id IN (5, 1, 2)
    -> ORDER BY CASE
    ->  WHEN id = 5 THEN 0
    ->  WHEN id = 1 THEN 1
    ->  WHEN id = 2 THEN 2
    -> END;
+----+-----------------------------------------+
| id | name                                    |
+----+-----------------------------------------+
|  5 | Видеокарты                              |
|  1 | NULL                                    |
|  2 | Сетевое оборудование                    |
+----+-----------------------------------------+
3 rows in set (0,00 sec)


# «Агрегация данных»

# № 1 Подсчитайте средний возраст пользователей в таблице users.

mysql> SELECT ROUND(AVG((TO_DAYS(NOW()) - TO_DAYS(birthday_at)) / 365.25), 0) AS AVG_Age FROM users;
+---------+
| AVG_Age |
+---------+
|      29 |
+---------+
1 row in set (0,00 sec)

# 2 Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. Следует учесть, что необходимы дни недели текущего года, а не года рождения.

mysql> SELECT
    -> DATE_FORMAT(DATE(CONCAT_WS('-', YEAR(NOW()), MONTH(birthday_at), DAY(birthday_at))), '%W') AS day,
    -> COUNT(*) AS total
    -> FROM
    -> users
    -> GROUP BY
    -> day
    -> ORDER BY
    -> total DESC;
+-----------+-------+
| day       | total |
+-----------+-------+
| Monday    |     2 |
| Friday    |     2 |
| Sunday    |     2 |
| Thursday  |     1 |
| Wednesday |     1 |
| Saturday  |     1 |
| Tuesday   |     1 |
+-----------+-------+
7 rows in set (0,00 sec)


# 3. (по желанию) Подсчитайте произведение чисел в столбце таблицы.
mysql> CREATE TABLE counter(
    ->  value SERIAL PRIMARY KEY
    -> );

mysql> SELECT * FROM counter;
+-------+
| value |
+-------+
|     1 |
|     2 |
|     3 |
|     4 |
|     5 |
|     6 |
+-------+
6 rows in set (0,00 sec)

mysql> SELECT ROUND(exp(SUM(ln(value))), 0) AS factorial FROM counter;
+-----------+
| factorial |
+-----------+
|       720 |
+-----------+
1 row in set (0,00 sec)


